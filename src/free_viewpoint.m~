function [output_image]  = free_viewpoint(IL, IR, varargin)
%% parse inputs
g = inputParser;
g.addOptional("p", 0.5, @isnumeric);
g.parse(varargin{:});
p = g.Results.p;

%% load camera params
disp('Loading Camera Parameters');
load('camera_param_1.mat', 'camera_param');
K = camera_param.IntrinsicMatrix';

%% undistortion lens from images
fprintf('1/8\t Undistorting Lens'); 
start = tic;
IL_d = undistort_image(IL,params.FocalLength(1),params.PrincipalPoint(1),params.PrincipalPoint(2),...
                       params.RadialDistortion(1),params.RadialDistortion(2),0,params.TangentialDistortion(1),...
                       params.TangentialDistortion(2));
IR_d = undistort_image(IR,params.FocalLength(1),params.PrincipalPoint(1),params.PrincipalPoint(2),...
                       params.RadialDistortion(1),params.RadialDistortion(2),0,params.TangentialDistortion(1),...
                       params.TangentialDistortion(2));


fprintf(': \t\t%.2fs\n', toc(start));

%% feature matching
fprintf('2/8\t Extracting Features'); 
start = tic;
Corr = feature_extracting_matching(IL,IR,false);
fprintf(': \t\t%.2fs\n', toc(start));

% get essential matrix
fprintf('3/8\t Estimate Essential Matrix'); 
start = tic;
E = eight_point_algorithm(Corr, K);
fprintf(': \t%.2fs\n', toc(start));

% compute eukledian motion
fprintf('4/8\t Computing Motion'); 
start = tic;
[R, T] = motion_estimation(Corr, E, K);
fprintf(': \t\t%.2fs\n', toc(start));

%% rectificate images (crop or not)
fprintf('5/8\t Apply Rectification');
start = tic;
[JL, JR, HomographyL, HomographyR] = rectification(IL, IR, R, T', K,'kit');
fprintf(': \t\t%.2fs\n', toc(start));

%% depth map 
% TODO: evt zweite disparity map für rechtes bild berechnen
% TODO: disparity map fct umschreiben, sodass korrespondenzpunkte
% übergeweben werden können
fprintf('6/8\t Creating Disparity Map');
start = tic;
[disparity_map,IL_resized,IR_resized] = calculateDisparityMap(JL,JR,'mode','block','size',800);
fprintf(': \t%.2fs\n', toc(start));

%% synthese
% NOTE: alle verabeitungsschritte vorher nur einmal auszuführen
%       synthese wird bei jedem neuen p durchgeführt
% TODO: holefilling nochmal anschaun
fprintf('7/8\t Synthesising new Image');
start = tic;
IM = synthesis(disparity_map, IL_resized, IR_resized, p);
fprintf(': \t%.2fs\n', toc(start));

%% derectification
% NOTE: not sure what homography matrix to choose
fprintf('8/8\t Inverting Rectification');
start = tic;
output_image = cv_inv_rectify(IM, HomographyL);
fprintf(': \t%.2fs\n', toc(start));
end

